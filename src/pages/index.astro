---
import Layout from "../layouts/Layout.astro";
---

<Layout>
  <div
    id="slot"
    class="min-h-screen bg-background flex-col flex justify-center items-center relative overflow-y-auto pb-32"
  >
    <h1 class="text-white text-center text-4xl md:text-7xl my-10 font-bowlby">
      Tech stack slot machine
    </h1>

    <div
      id="reels"
      class="mx-auto flex w-[90%] lg:w-full h-[calc((3/5)*85vw)] lg:h-[calc((3/5)*100vw)] max-h-[calc(90vh-50px-55px)] lg:max-h-[calc(90vh-50px-55px)] max-w-[calc((5/3)*(90vh-50px-40px))] border-2 lg:border-4 border-border rounded-md"
    >
      <div class="reel border-l-2 md:border-l-4 border-l-border"></div>
      <div class="reel border-l-2 md:border-l-4 border-l-border"></div>
      <div class="reel border-l-2 md:border-l-4 border-l-border"></div>
      <div class="reel border-l-2 md:border-l-4 border-l-border"></div>
      <div class="reel border-l-2 md:border-l-4 border-l-border"></div>
    </div>
    <div class="flex mt-10 justify-between items-center gap-4 mx-auto">
      <button type="button" id="spin" class="text-white font-bowlby border-2 border-white px-8 py-4 text-lg"
        >Spin</button
      >
    </div>
  </div>

  <style is:global>
    .reel {
      overflow: hidden;
      width: 20%;
      height: 100%;
      position: relative;
    }

    .reel > .icons {
      position: relative;
    }

    .reel > .icons > img {
      width: calc(100% + 6px);
      margin: -3px 0 0 -3px;
      height: auto;
      /* enable gpu accelaration, fixes iOS flicker */
      transform: translate3d(0, 0, 0);
    }

    #slot.inverted .reel {
      transform: scaleY(-1);
    }

    #slot.inverted .reel > .icons > img {
      transform: scaleY(-1);
    }
  </style>

  <script>
    import { getLogoById } from "../utils";
    import { SYMBOL_GROUPS } from "../constants/symbol-groups";
    const spinSoundElem = document.querySelector("#spin-sound");
    const result = document.querySelector("#result");
    const cache: Record<string, HTMLImageElement> = {};

    class Symbol {
      name: string;
      img: HTMLImageElement;

      constructor(name: string = Symbol.random()) {
        this.name = name;

        if (cache[name]) {
          this.img = cache[name].cloneNode() as HTMLImageElement;
        } else {
          this.img = new Image();
          const logo = getLogoById(name);
          if (!logo) {
            throw new Error("Logo is undefined!");
          }
          this.img.src = logo.logo;
          this.img.alt = `${logo.name} logo`;
          cache[name] = this.img;
        }
      }

      static preload(c: string): void {
        Symbol.getSymbols(c).forEach((symbol) => new Symbol(symbol));
      }

      static getSymbols(category?: string): string[] {
        const frontend = SYMBOL_GROUPS.frontend.map((item) => item.id);
        const backend = SYMBOL_GROUPS.backend.map((item) => item.id);
        const styling = SYMBOL_GROUPS.styling.map((item) => item.id);
        const database = SYMBOL_GROUPS.database.map((item) => item.id);
        const deployment = SYMBOL_GROUPS.deployment.map((item) => item.id);

        switch (category) {
          case "frontend":
            return frontend;
          case "backend":
            return backend;
          case "styling":
            return styling;
          case "database":
            return database;
          case "deployment":
            return deployment;
          default:
            return [
              ...frontend,
              ...backend,
              ...database,
              ...styling,
              ...deployment,
            ];
        }
      }

      static random(category?: string): string {
        const symbols = this.getSymbols(category);
        return symbols[Math.floor(Math.random() * symbols.length)];
      }
    }

    class Reel {
      reelContainer: HTMLElement;
      idx: number;
      symbolContainer: HTMLDivElement;
      animation: Animation;

      constructor(
        reelContainer: HTMLElement,
        idx: number,
        initialSymbols: string[]
      ) {
        this.reelContainer = reelContainer;
        this.idx = idx;

        this.symbolContainer = document.createElement("div");
        this.symbolContainer.classList.add("icons");
        this.reelContainer.appendChild(this.symbolContainer);

        this.animation = this.symbolContainer.animate(
          [
            { top: "0", filter: "blur(0)" },
            { filter: "blur(2px)", offset: 0.2 },
            {
              top: `calc((${Math.floor(this.factor) * 10} / 3) * -100% - (${
                Math.floor(this.factor) * 10
              } * 0.2px))`,
              filter: "blur(0)",
            },
          ],
          {
            duration: this.factor * 750,
            easing: "ease-in-out",
          }
        );

        this.animation.cancel();

        initialSymbols.forEach((symbol) =>
          this.symbolContainer.appendChild(new Symbol(symbol).img)
        );
      }

      get factor(): number {
        return 1 + Math.pow(this.idx / 2, 2);
      }

      renderSymbols(nextSymbols: string[]): void {
        const fragment = document.createDocumentFragment();

        for (let i = 3; i < 3 + Math.floor(this.factor) * 10; i++) {
          const icon = new Symbol(
            i >= 10 * Math.floor(this.factor) - 2
              ? nextSymbols[i - Math.floor(this.factor) * 10]
              : undefined
          );
          fragment.appendChild(icon.img);
        }

        this.symbolContainer.appendChild(fragment);
      }

      spin(): Promise<void> {
        const animationPromise = new Promise<void>(
          (resolve) => (this.animation.onfinish = () => resolve())
        );
        const timeoutPromise = new Promise<void>((resolve) =>
          setTimeout(() => resolve(), this.factor * 1000)
        );

        this.animation.cancel();
        this.animation.play();

        return Promise.race([animationPromise, timeoutPromise]).then(() => {
          if (this.animation.playState !== "finished") this.animation.finish();

          const max = this.symbolContainer.children.length - 3;

          for (let i = 0; i < max; i++) {
            this.symbolContainer.firstChild?.remove();
          }
        });
      }
    }

    interface SlotConfig {
      inverted?: boolean;
      onSpinStart?: (symbols: string[][]) => void;
      onSpinEnd?: (symbols: string[][]) => void;
    }

    class Slot {
      currentSymbols: string[][];
      nextSymbols: string[][];
      container: HTMLElement;
      reels: Reel[];
      spinButton: HTMLButtonElement;
      autoPlayCheckbox: HTMLInputElement;
      config: SlotConfig;

      constructor(domElement: HTMLElement, config: SlotConfig = {}) {
        Symbol.preload("deployment");

        this.currentSymbols = [
          ["reactJs", "vueJs", "angularJs"],
          ["nodeJs", "springboot", "django"],
          ["mui", "si", "antd"],
          ["mongodb", "postgres", "mysql"],
          ["vercel", "aws", "azure"],
        ];

        this.nextSymbols = [
          ["reactJs", "reactJs", "reactJs"],
          ["reactJs", "reactJs", "reactJs"],
          ["reactJs", "reactJs", "reactJs"],
          ["reactJs", "reactJs", "reactJs"],
          ["reactJs", "reactJs", "reactJs"],
        ];

        this.container = domElement;

        this.reels = Array.from(
          this.container.getElementsByClassName("reel")
        ).map(
          (reelContainer, idx) =>
            new Reel(
              reelContainer as HTMLElement,
              idx,
              this.currentSymbols[idx]
            )
        );
        this.spinButton = document.getElementById("spin") as HTMLButtonElement;
        this.spinButton.addEventListener("click", () => this.spin());

        this.autoPlayCheckbox = document.getElementById(
          "autoplay"
        ) as HTMLInputElement;

        if (config.inverted) {
          this.container.classList.add("inverted");
        }

        this.config = config;
      }

      spin(): Promise<void> {
        this.currentSymbols = this.nextSymbols;
        this.nextSymbols = [
          [
            Symbol.random("frontend"),
            Symbol.random("frontend"),
            Symbol.random("frontend"),
          ],
          [
            Symbol.random("backend"),
            Symbol.random("backend"),
            Symbol.random("backend"),
          ],
          [
            Symbol.random("styling"),
            Symbol.random("styling"),
            Symbol.random("styling"),
          ],
          [
            Symbol.random("deployment"),
            Symbol.random("deployment"),
            Symbol.random("deployment"),
          ],
          [
            Symbol.random("database"),
            Symbol.random("database"),
            Symbol.random("database"),
          ],
        ];

        this.onSpinStart(this.nextSymbols);

        return Promise.all(
          this.reels.map((reel) => {
            reel.renderSymbols(this.nextSymbols[reel.idx]);
            // @ts-ignore
            // spinSoundElem?.play();
            return reel.spin();
          })
        ).then(() => this.onSpinEnd(this.nextSymbols));
      }

      onSpinStart(symbols: string[][]): void {
        this.spinButton.disabled = true;
        this.config.onSpinStart?.(symbols);
        // if (result) {
        //   result.classList.add("hidden");
        // }
      }

      onSpinEnd(symbols: string[][]): void {
        this.spinButton.disabled = false;
        this.config.onSpinEnd?.(symbols);
        // if (result) {
        //   result.classList.remove("hidden");
        // }
      }
    }
    const config: SlotConfig = {
      inverted: false,
      onSpinStart: (symbols) => {
        console.log("onSpinStart", symbols);
      },
      onSpinEnd: (symbols) => {
        console.log("onSpinEnd", symbols);
      },
    };

    const slot = new Slot(
      document.getElementById("slot") as HTMLElement,
      config
    );

    // const arm = document.getElementById("arm");
    // arm?.addEventListener("click", function (e) {
    //   this.classList.add("clicked");
    //   slot.spin();
    //   setTimeout(function () {
    //     arm?.classList.remove("clicked");
    //   }, 500 * 5);
    //   e.preventDefault();
    // });
  </script>
</Layout>
