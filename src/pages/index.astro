---
import Layout from "@/layouts/Layout.astro";
---

<Layout>
  <div
    id="slot"
    class="min-h-screen bg-background flex-col flex justify-center items-center relative overflow-y-auto pb-32"
  >
    <h1
      class="text-white text-center text-4xl md:text-5xl lg:text-6xl xl:text-7xl my-10 font-bowlby"
      id="heading"
    >
      Tech stack slot machine
    </h1>

    <div class="flex gap-4 justify-center items-start md:flex-row flex-col">
      <div
        id="reels"
        class="mx-auto flex w-[90%] lg:w-full h-[calc((3/5)*85vw)] lg:h-[600px] max-h-[calc(90vh-50px-55px)] lg:max-h-[calc(90vh-50px-55px)] max-w-[calc((5/3)*(90vh-50px-40px))] border-2 lg:border-4 border-border rounded-md relative"
      >
        <!-- Left triangle -->
        <svg
          xmlns="http://www.w3.org/2000/svg"
          width="30"
          height="30"
          viewBox="0 0 24 24"
          fill="#db0000"
          stroke="#db0000"
          stroke-width="3"
          stroke-linecap="round"
          stroke-linejoin="round"
          class="lucide lucide-play absolute -left-1 md:-left-2 top-1/2 transform -translate-y-1/2 z-30 size-4 md:size-8"
          ><polygon points="6 3 20 12 6 21 6 3"></polygon></svg
        >
        <!-- Right triangle -->
        <svg
          xmlns="http://www.w3.org/2000/svg"
          width="30"
          height="30"
          viewBox="0 0 24 24"
          fill="#db0000"
          stroke="#db0000"
          stroke-width="3"
          stroke-linecap="round"
          stroke-linejoin="round"
          class="lucide lucide-play absolute -right-1  md:-right-2 top-1/2 transform -translate-y-1/2 rotate-180 z-30 size-4 md:size-8"
          ><polygon points="6 3 20 12 6 21 6 3"></polygon></svg
        >

        <!-- Center line -->
        <div
          class="h-[1px] md:h-[2px] w-full absolute right-0 top-1/2 transform -translate-y-1/2 z-20 bg-secondary-foreground opacity-50"
        >
        </div>


        <div class="reel border-l-2 md:border-l-4 border-l-transparent"></div>
        <div class="reel border-l-2 md:border-l-4 border-l-border"></div>
        <div class="reel border-l-2 md:border-l-4 border-l-border"></div>
        <div class="reel border-l-2 md:border-l-4 border-l-border"></div>
        <div class="reel border-l-2 md:border-l-4 border-l-border"></div>
      </div>
      <div
        class="flex justify-between items-center gap-4 mt-4 md:mt-0 mx-auto w-[90%] md:w-min"
      >
        <button
          type="button"
          id="spin"
          class="text-white font-bowlby w-full border-2 md:w-min border-white px-8 py-4 text-lg"
          >Spin</button
        >

        <button class="border-4 p-4 border-border" id="toggleSound">
          <span aria-hidden="true" class="text-xl">ðŸ”Š</span>
        </button>

        <!-- <Arm /> -->
      </div>
    </div>
  </div>
</Layout>

<style is:global>
  .reel {
    overflow: hidden;
    width: 20%;
    height: 100%;
    position: relative;
  }

  .reel > .icons {
    position: relative;
  }

  .reel > .icons > img {
    width: calc(100% + 6px);
    margin: -3px 0 0 -3px;
    height: auto;
     border-bottom: 1px solid #27272A; 

    /* enable gpu accelaration, fixes iOS flicker */
    transform: translate3d(0, 0, 0);
  }

  #slot.inverted .reel {
    transform: scaleY(-1);
  }

  #slot.inverted .reel > .icons > img {
    transform: scaleY(-1);
  }
</style>

<script>
  import { getLogoById } from "../utils";
  import { SYMBOL_GROUPS } from "../constants/symbol-groups";
  import { Sound } from "../js/sound";
  const spinSoundElem = document.querySelector("#spin-sound");
  const result = document.querySelector("#result");
  const blip = document.querySelector("#blip-sound");
  const cache: Record<string, HTMLImageElement> = {};
  let isSoundOn = true;

  class SoundServiceClass {
    blipSound = new Sound(
      "https://utfs.io/f/42412a11-0bbe-4fdd-a5de-c013ae844e3f-1sve9.mp3"
    );
    buttonSound = new Sound(
      "https://utfs.io/f/3e9c13cf-8aa5-4ca0-92b5-8ada3a255423-4vv1d1.mp3"
    );
    soundsStatus = "loading";
    isEnabled = false;
    private _currentVolume = 0.7;

    constructor() {
      this.loadSounds();
    }

    loadSounds() {
      this.soundsStatus = "loading";
      this.isEnabled = false;

      Promise.all([this.blipSound.load(), this.buttonSound.load()])
        .then(() => {
          this.soundsStatus = "loaded";
          this.isEnabled = true;
        })
        .catch(() => {
          this.soundsStatus = "error";
          this.isEnabled = false;
        });
    }

    enable() {
      if (this.soundsStatus === "loaded") {
        this.isEnabled = true;
      } else if (this.soundsStatus === "error") {
        this.loadSounds();
      }
    }

    disable() {
      if (this.soundsStatus !== "loaded") return;
      this.blipSound.stop();
      this.buttonSound.stop();
      this.isEnabled = false;
      this.blipSound.stop();
    }

    // @ts-ignore
    blip(...args) {
      // @ts-ignore
      if (this.isEnabled) {
        const volumeAdjustedArgs = [this._currentVolume, ...args];
        this.blipSound.play(...volumeAdjustedArgs);
      }
    }

    // @ts-ignore
    button(...args) {
      this.buttonSound.play(...args);
    }

    set currentVolume(value: number) {
      this._currentVolume = Math.max(0, Math.min(1, value));
    }

    get currentVolume() {
      return this._currentVolume;
    }
  }

  const SMSoundService = new SoundServiceClass();

  class Symbol {
    name: string;
    img: HTMLImageElement;

    constructor(name: string = Symbol.random()) {
      this.name = name;

      if (cache[name]) {
        this.img = cache[name].cloneNode() as HTMLImageElement;
      } else {
        this.img = new Image();
        const logo = getLogoById(name);
        if (!logo) {
          throw new Error("Logo is undefined!");
        }
        this.img.src = logo.logo;
        this.img.alt = `${logo.name} logo`;
        cache[name] = this.img;
      }
    }

    static preload(c: string): void {
      Symbol.getSymbols(c).forEach((symbol) => new Symbol(symbol));
    }

    static getSymbols(category?: string): string[] {
      const frontend = SYMBOL_GROUPS.frontend.map((item) => item.id);
      const backend = SYMBOL_GROUPS.backend.map((item) => item.id);
      const styling = SYMBOL_GROUPS.styling.map((item) => item.id);
      const database = SYMBOL_GROUPS.database.map((item) => item.id);
      const deployment = SYMBOL_GROUPS.deployment.map((item) => item.id);

      switch (category) {
        case "frontend":
          return frontend;
        case "backend":
          return backend;
        case "styling":
          return styling;
        case "database":
          return database;
        case "deployment":
          return deployment;
        default:
          return [
            ...frontend,
            ...backend,
            ...database,
            ...styling,
            ...deployment,
          ];
      }
    }

    static random(category?: string): string {
      const symbols = this.getSymbols(category);
      return symbols[Math.floor(Math.random() * symbols.length)];
    }
  }

  class Reel {
    reelContainer: HTMLElement;
    idx: number;
    symbolContainer: HTMLDivElement;
    animation: Animation;

    constructor(
      reelContainer: HTMLElement,
      idx: number,
      initialSymbols: string[]
    ) {
      this.reelContainer = reelContainer;
      this.idx = idx;

      this.symbolContainer = document.createElement("div");
      this.symbolContainer.classList.add("icons");
      this.reelContainer.appendChild(this.symbolContainer);

      this.animation = this.symbolContainer.animate(
        [
          { top: "0", filter: "blur(0)" },
          { filter: "blur(2px)", offset: 0.2 },
          {
            top: `calc((${Math.floor(this.factor) * 10} / 3) * -100% - (${
              Math.floor(this.factor) * 10
            } * 0.2px))`,
            filter: "blur(0)",
          },
        ],
        {
          duration: this.factor * 750,
          easing: "ease-in-out",
        }
      );
      this.animation.cancel();

      initialSymbols.forEach((symbol) => {
        this.symbolContainer.appendChild(new Symbol(symbol).img);
      });
    }

    get factor(): number {
      return 1 + Math.pow(this.idx / 2, 2);
    }

    renderSymbols(nextSymbols: string[]): void {
      const fragment = document.createDocumentFragment();

      for (let i = 3; i < 3 + Math.floor(this.factor) * 10; i++) {
        const icon = new Symbol(
          i >= 10 * Math.floor(this.factor) - 2
            ? nextSymbols[i - Math.floor(this.factor) * 10]
            : undefined
        );
        fragment.appendChild(icon.img);
      }

      this.symbolContainer.appendChild(fragment);
    }

    spin(): Promise<void> {
      const animationPromise = new Promise<void>(
        (resolve) => (this.animation.onfinish = () => resolve())
      );
      const timeoutPromise = new Promise<void>((resolve) =>
        setTimeout(() => resolve(), this.factor * 1000)
      );

      this.animation.cancel();
      this.animation.play();

      return Promise.race([animationPromise, timeoutPromise]).then(() => {
        if (this.animation.playState !== "finished") this.animation.finish();

        const max = this.symbolContainer.children.length - 3;

        for (let i = 0; i < max; i++) {
          this.symbolContainer.firstChild?.remove();
        }
      });
    }
  }

  interface SlotConfig {
    inverted?: boolean;
    onSpinStart?: (symbols: string[][]) => void;
    onSpinEnd?: (symbols: string[][]) => void;
  }

  class Slot {
    currentSymbols: string[][];
    nextSymbols: string[][];
    container: HTMLElement;
    reels: Reel[];
    spinButton: HTMLButtonElement;
    autoPlayCheckbox: HTMLInputElement;
    config: SlotConfig;
    intervalId: number | null;

    constructor(domElement: HTMLElement, config: SlotConfig = {}) {
      Symbol.preload("deployment");

      this.currentSymbols = [
        ["reactJs", "vueJs", "angularJs"],
        ["nodeJs", "springboot", "django"],
        ["mui", "si", "antd"],
        ["mongodb", "postgres", "mysql"],
        ["vercel", "aws", "azure"],
      ];

      this.nextSymbols = [
        ["reactJs", "reactJs", "reactJs"],
        ["reactJs", "reactJs", "reactJs"],
        ["reactJs", "reactJs", "reactJs"],
        ["reactJs", "reactJs", "reactJs"],
        ["reactJs", "reactJs", "reactJs"],
      ];

      this.container = domElement;

      this.reels = Array.from(
        this.container.getElementsByClassName("reel")
      ).map(
        (reelContainer, idx) =>
          new Reel(reelContainer as HTMLElement, idx, this.currentSymbols[idx])
      );
      this.spinButton = document.getElementById("spin") as HTMLButtonElement;
      this.spinButton.addEventListener("click", () => {
        this.spin();
        // SMSoundService.blip();
      });

      this.autoPlayCheckbox = document.getElementById(
        "autoplay"
      ) as HTMLInputElement;

      if (config.inverted) {
        this.container.classList.add("inverted");
      }

      this.config = config;
      this.intervalId = null;
    }

    spin(): Promise<void> {
      // SMSoundService.enable();
      // this.intervalId = window.setInterval(() => {
      //   if (SMSoundService.isEnabled) {
      //     SMSoundService.blip();
      //   }
      // }, 100);

      if (isSoundOn) {
        SMSoundService.enable();
        SMSoundService.currentVolume = 0.6;

        const intervalDuration = 3750;
        const volumeDecreaseInterval = 100;
        const totalSteps = intervalDuration / volumeDecreaseInterval;
        let currentStep = 0;
        const startVolume = SMSoundService.currentVolume;

        this.intervalId = window.setInterval(() => {
          if (SMSoundService.isEnabled) {
            currentStep++;
            const volumeDecreaseRatio = Math.pow(currentStep / totalSteps, 0.9);
            const newVolume = startVolume * (1 - volumeDecreaseRatio);

            SMSoundService.currentVolume = Math.max(0, newVolume);
            SMSoundService.blip();

            if (currentStep >= totalSteps) {
              clearInterval(this.intervalId as any);
              this.intervalId = null;
              SMSoundService.currentVolume = 0;
            }
          }
        }, volumeDecreaseInterval);
      }

      // ðŸ“–ðŸ“–ðŸ“–ðŸ“–ðŸ“–ðŸ“–ðŸ“–ðŸ“–ðŸ“–ðŸ“–
      this.currentSymbols = this.nextSymbols;
      this.nextSymbols = [
        [
          Symbol.random("frontend"),
          Symbol.random("frontend"),
          Symbol.random("frontend"),
        ],
        [
          Symbol.random("backend"),
          Symbol.random("backend"),
          Symbol.random("backend"),
        ],
        [
          Symbol.random("styling"),
          Symbol.random("styling"),
          Symbol.random("styling"),
        ],
        [
          Symbol.random("deployment"),
          Symbol.random("deployment"),
          Symbol.random("deployment"),
        ],
        [
          Symbol.random("database"),
          Symbol.random("database"),
          Symbol.random("database"),
        ],
      ];

      this.onSpinStart(this.nextSymbols);

      return Promise.all(
        this.reels.map((reel) => {
          reel.renderSymbols(this.nextSymbols[reel.idx]);

          return reel.spin();
        })
      ).then(() => {
        this.onSpinEnd(this.nextSymbols);
        SMSoundService.disable();
      });
    }

    onSpinStart(symbols: string[][]): void {
      this.spinButton.disabled = true;
      this.config.onSpinStart?.(symbols);
      // if (result) {
      //   result.classList.add("hidden");
      // }
    }

    onSpinEnd(symbols: string[][]): void {
      this.config.onSpinEnd?.(symbols);
      this.spinButton.disabled = false;
      if (this.intervalId !== null) {
        clearInterval(this.intervalId);
        this.intervalId = null;
      }
    }
  }

  const config: SlotConfig = {
    inverted: false,
    onSpinStart: (symbols) => {
      console.log("onSpinStart", symbols);
    },
    onSpinEnd: (symbols) => {
      console.log("onSpinEnd", symbols);
    },
  };

  const slot = new Slot(document.getElementById("slot") as HTMLElement, config);
  document.addEventListener("DOMContentLoaded", function () {
    const toggleSound = document.getElementById("toggleSound");
    const soundIcon = toggleSound?.querySelector("span");
    isSoundOn = JSON.parse(window.localStorage.getItem("isSoundOn") || "true");
    if (isSoundOn) {
      SMSoundService.enable();
      window.localStorage.setItem("isSoundOn", "true");
      if (soundIcon) {
        soundIcon.textContent = "ðŸ”Š";
      }
    } else {
      SMSoundService.disable();
      window.localStorage.setItem("isSoundOn", "false");
      if (soundIcon) {
        soundIcon.textContent = "ðŸ”‡";
      }
    }

    if (toggleSound && soundIcon) {
      toggleSound.addEventListener("click", function () {
        isSoundOn = !isSoundOn;

        if (isSoundOn) {
          soundIcon.textContent = "ðŸ”Š";
          SMSoundService.enable();
          window.localStorage.setItem("isSoundOn", "true");
        } else {
          soundIcon.textContent = "ðŸ”‡";
          SMSoundService.disable();
          window.localStorage.setItem("isSoundOn", "false");
        }
      });
    }
  });
</script>
